max_warnings 2

Set w 9
Set h 7
Set sw 4
Set sh 4

Define Simple_Tests 0
Perform_Some_Tests Simple_Test
.

Define Subimage_Tests 0
Perform_Some_Tests Subimage_Test
.

Define Illegal_Subimage_Tests 0
Perform_Some_Tests Illegal_Subimage_Test2
Perform_Some_Tests Illegal_Subimage_Test1
.

Define Perform_Some_Tests 1 test_macro
$1 short u_byte 1 2
$1 int u_byte 1 4
$1 long u_byte 1 8
$1 u_byte short 2 1
$1 u_byte int 4 1
$1 u_byte long 8 1
.

Define Simple_Test 4 'parent precision' 'child precision' 'parent multiplier' 'child multiplier'
#Image parent_$1 $h $w*$3 1 $1
Image parent_$1 $h $w $3 $1
Info parent_$1
#Equivalence child_$2 parent_$1 1 1 $h $w*$4 1 $2
Equivalence child_$2 parent_$1 1 1 $h $w $4 $2
Info child_$2
Pause
Delete_Image parent_$1	# automatically deletes the child also
.

Define Illegal_Subimage_Test1 4 'parent precision' 'child precision' 'parent multiplier' 'child multiplier'
Image parent_$1 $h $w $3 $1
Subimage inset_$1 parent_$1 $sw $sh 1 1
Info inset_$1
Equivalence child_$2 inset_$1 1 1 1 $sh*$sw $4 $2
If obj_exists(child_$2) "Info child_$2"
Pause
Delete_Image parent_$1	# automatically deletes the child also
.

Define Illegal_Subimage_Test2 4 'parent precision' 'child precision' 'parent multiplier' 'child multiplier'
Image parent_$1 $h $w*$3 3 $1
Subimage inset_$1 parent_$1{0} $sw $sh 1 1
Info parent_$1
Info inset_$1
advise "Illegal_Subimage_Test2 $1 $2 $3 $4"
expect_warning 'error making'
expect_warning 'get'
Equivalence child_$2 inset_$1 1 1 1 $sh*$sw $4 $2
If obj_exists(child_$2) "Info child_$2"
Pause
Delete_Image parent_$1	# automatically deletes the child also
.

Define Subimage_Test 4 'parent precision' 'child precision' 'parent multiplier' 'child multiplier'
Image parent_$1 $h $w $3 $1
Subimage inset_$1 parent_$1 $sw $sh 1 1
Info inset_$1
Equivalence child_$2 inset_$1 1 1 $sh $sw $4 $2
Info child_$2
Pause
Delete_Image parent_$1	# automatically deletes the child also
.


Define Test_Bitmaps 0
Set h 4
Set w 76
Set t 1

Sequence b1 $t $h $w 1 bit
Info b1

#advise "Interlacing bit image:"
#Interlace odd b1 odd
#Info odd
#Pause

advise "Equivalencing bit to u_int:"
Equivalence el1 b1 1 $t $h 4 1 u_int
Info el1
advise ' '

advise "Equivalencing bit to u_long:"
Equivalence el2 b1 1 $t $h 2 1 u_long
Info el2
advise ' '

advise "Equivalencing back to bit"
Equivalence eb1 el2 1 $t $h 128 1 bit
Info eb1
advise ' '
.

Define Test_Complex 0
Set h 4
Set w 5
Image f1 $h $w 1 float
Image c1 $h $w 1 complex

advise "Equivalencing floats to complex..."
Equivalence ef1 f1 1 1 $h/2 $w 1 complex
Info ef1

advise "Equivalencing complex to float..."
Equivalence ec1 c1 1 1 $h $w 2 float
Info ec1
.

Define Test_Misc 0
Set h 9
Set w 8

Image y1 $h $w 1 u_byte
Image f1 $h $w 1 float

advise 'Equivalencing float to byte:'
Equivalence ub1 f1 1 1 $h $w 4 u_byte
Info f1
Info ub1

Equivalence ey1 y1 1 1 $h $w/4 1 u_int
advise "Equivalencing byte to u_int:"
Info y1
Info ey1

Delete_Image f1
Delete_Image y1
.

#Test_Bitmaps
#Test_Misc
#Test_Complex

Illegal_Subimage_Tests
Simple_Tests
Subimage_Tests

exit

